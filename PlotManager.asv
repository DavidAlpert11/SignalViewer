classdef PlotManager < handle
    properties
        App
        PlotTabs
        AxesArrays
        AssignedSignals
        TabLayouts
        LinkedAxes
        SelectedSubplotIdx
        CurrentTabIdx
        GridLayouts
        % Add properties for stable streaming
        AxesLimits  % Store current limits to prevent jumping
        LastDataTime % Track last data time for each axes
    end

    methods
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % PlotManager Methods
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        % Constructor
        function obj = PlotManager(app)
            % Create a PlotManager for the given app
            obj.App = app;
            obj.PlotTabs = {};
            obj.AxesArrays = {};
            obj.AssignedSignals = {};
            obj.TabLayouts = {};
            obj.GridLayouts = {};
            obj.LinkedAxes = matlab.graphics.axis.Axes.empty;
            obj.CurrentTabIdx = 1;
            obj.SelectedSubplotIdx = 1;
            obj.AxesLimits = {};  % Initialize limits tracking
            obj.LastDataTime = {};  % Initialize time tracking
        end

        % Initialize the plot manager (create the first tab)
        function initialize(obj)
            obj.createFirstTab();
        end

        % Create the first tab with default layout and context menu
        function createFirstTab(obj)
            % Create first tab with LIGHT MODE styling
            tab = uitab(obj.App.MainTabGroup, 'Title', 'Tab 1 ❌', ...
                'BackgroundColor', [0.98 0.98 0.98]);
            % Add context menu for closing
            cm = uicontextmenu(obj.App.UIFigure);
            uimenu(cm, 'Text', 'Close Tab', 'MenuSelectedFcn', @(src, event) obj.deleteTabByHandle(tab));
            tab.ContextMenu = cm;
            obj.PlotTabs{1} = tab;
            obj.GridLayouts{1} = uigridlayout(tab, [2, 1], ...
                'BackgroundColor', [0.98 0.98 0.98]);   % Light background
            obj.AxesArrays{1} = matlab.ui.control.UIAxes.empty;

            obj.AssignedSignals{1} = cell(2, 1);
            for i = 1:2
                obj.AssignedSignals{1}{i} = {};
            end

            obj.TabLayouts{1} = [2, 1];
            obj.createSubplotsForTab(1, 2, 1);
            obj.CurrentTabIdx = 1;
            
            % Highlight the first subplot
            obj.App.highlightSelectedSubplot(1, 1);

            % Ensure the + tab exists
            obj.ensurePlusTab();
        end

        % Create subplots for a given tab with specified rows and columns
        function createSubplotsForTab(obj, tabIdx, rows, cols)
            % Defensive: check tabIdx
            if tabIdx > numel(obj.PlotTabs)
                return;
            end

            obj.TabLayouts{tabIdx} = [rows, cols];

            % Delete old axes and grid layout
            if ~isempty(obj.AxesArrays{tabIdx})
                for ax = obj.AxesArrays{tabIdx}
                    if isvalid(ax)
                        delete(ax);
                    end
                end
            end
            if ~isempty(obj.GridLayouts{tabIdx}) && isvalid(obj.GridLayouts{tabIdx})
                delete(obj.GridLayouts{tabIdx});
            end

            % Create new grid layout and uiaxes
            obj.GridLayouts{tabIdx} = uigridlayout(obj.PlotTabs{tabIdx}, [rows, cols], 'BackgroundColor', [1 1 1]);
            nPlots = rows * cols;
            obj.AxesArrays{tabIdx} = gobjects(1, nPlots);
            
            % Initialize limits tracking for this tab
            obj.AxesLimits{tabIdx} = cell(1, nPlots);
            obj.LastDataTime{tabIdx} = cell(1, nPlots);
            
            for i = 1:nPlots
                ax = uiaxes(obj.GridLayouts{tabIdx});
                ax.Layout.Row = ceil(i/cols);
                ax.Layout.Column = mod(i-1, cols)+1;
                
                % Set up proper axes styling with grid enabled by default
                ax.Color = [1 1 1];
                ax.Box = 'on';
                ax.XLabel.String = 'Time';
                ax.YLabel.String = 'Value';
                
                % Enable grid and minor grid by default
                grid(ax, 'on');
                ax.XGrid = 'on';
                ax.YGrid = 'on';
                ax.XMinorGrid = 'on';
                ax.YMinorGrid = 'on';
                ax.GridAlpha = 0.3;
                ax.MinorGridAlpha = 0.1;
                
                % DON'T set any default limits - let MATLAB auto-scale
                % Leave axes in 'auto' mode initially
                ax.XLimMode = 'auto';
                ax.YLimMode = 'auto';
                
                % Initialize limits tracking with empty values
                obj.AxesLimits{tabIdx}{i} = struct('XLim', [], 'YLim', [], 'HasData', false);
                obj.LastDataTime{tabIdx}{i} = 0;
                
                % Add click callback for subplot selection
                ax.ButtonDownFcn = @(src, event) obj.selectSubplot(tabIdx, i);
                obj.AxesArrays{tabIdx}(i) = ax;
            end
            
            % Immediately refresh plots for this tab so checked signals are shown
            obj.App.PlotManager.refreshPlots(tabIdx);
            % Highlight the selected subplot
            obj.App.highlightSelectedSubplot(tabIdx, obj.SelectedSubplotIdx);
        end

        % **MAIN METHOD: Improved refreshPlots with streaming optimization - NO CLEARING DURING STREAMING**
        function refreshPlots(obj, tabIndices)
            if ~isprop(obj.App, 'DataManager') || isempty(obj.App.DataManager) || ~isvalid(obj.App.DataManager)
                return;
            end
            if nargin < 2
                tabIndices = 1:numel(obj.AxesArrays);
            end
            if isempty(obj.App.DataManager.DataTables) || all(cellfun(@isempty, obj.App.DataManager.DataTables))
                return;
            end
            
            % Track axes that need final auto-scaling
            axesToAutoScale = [];
            
            for tabIdx = tabIndices
                if tabIdx > numel(obj.AxesArrays) || isempty(obj.AxesArrays{tabIdx})
                    continue;
                end
                axesArr = obj.AxesArrays{tabIdx};
                assignments = obj.AssignedSignals{tabIdx};
                n = min(numel(axesArr), numel(assignments));
                
                for k = 1:n
                    ax = axesArr(k);
                    
                    % Validate axes exists and is valid before proceeding
                    if ~isvalid(ax) || ~isgraphics(ax)
                        continue;
                    end
                    
                    % Store current limits and check streaming state
                    currentXLim = ax.XLim;
                    currentYLim = ax.YLim;
                    hasExistingData = ~isempty(ax.Children);
                    isStreaming = obj.App.DataManager.IsRunning;
                    
                    % **CONDITIONAL CLEARING - only clear if not streaming or no existing data**
                    shouldClearAndRecreate = ~isStreaming || ~hasExistingData;
                    
                    if shouldClearAndRecreate
                        % Full refresh: clear everything
                        delete(ax.Children);
                    end
                    
                    % Restore and maintain grid settings (always)
                    grid(ax, 'on');
                    ax.XGrid = 'on';
                    ax.YGrid = 'on';
                    ax.XMinorGrid = 'on';
                    ax.YMinorGrid = 'on';
                    ax.GridAlpha = 0.3;
                    ax.MinorGridAlpha = 0.1;
                    
                    hold(ax, 'on');
                    sigs = assignments{k};
                    
                    if isempty(sigs)
                        % No signals assigned - let axes auto-scale or keep existing limits
                        if shouldClearAndRecreate
                            % Only set defaults if we cleared everything and not streaming
                            if ~isStreaming
                                % Let auto-scaling handle empty axes
                                ax.XLimMode = 'auto';
                                ax.YLimMode = 'auto';
                            else
                                % During streaming, keep reasonable defaults
                                ax.
                                ax.XLimMode = 'manual';
                                ax.YLimMode = 'manual';
                            end
                        else
                            % Keep existing limits and remove all signal plots
                            obj.removeAllSignalPlots(ax);
                            ax.XLim = currentXLim;
                            ax.YLim = currentYLim;
                            ax.XLimMode = 'manual';
                            ax.YLimMode = 'manual';
                        end
                        hold(ax, 'off');
                        continue;
                    end
                    
                    % Collect all time and value data for limit calculation
                    allTimeData = [];
                    allValueData = [];
                    plotHandles = [];
                    plotLabels = {};
                    assignedSignalNames = {};
                    
                    % Use axes ColorOrder for default colors
                    colorOrder = ax.ColorOrder;
                    nColors = size(colorOrder,1);
                    colorIdx = 1;
                    
                    % Plot all signals
                    for j = 1:numel(sigs)
                        sigInfo = sigs{j};
                        sigName = sigInfo.Signal;
                        assignedSignalNames{end+1} = sigName;
                        
                        T = obj.App.DataManager.DataTables{sigInfo.CSVIdx};
                        if ~ismember(sigName, T.Properties.VariableNames)
                            continue;
                        end
                        
                        validData = ~isnan(T.(sigName));
                        if ~any(validData)
                            continue;
                        end
                        
                        timeData = T.Time(validData);
                        signalData = T.(sigName)(validData);
                        
                        % Apply scaling
                        scaleFactor = 1.0;
                        if obj.App.DataManager.SignalScaling.isKey(sigName)
                            scaleFactor = obj.App.DataManager.SignalScaling(sigName);
                        end
                        scaledData = signalData * scaleFactor;
                        
                        % Collect data for limit calculation
                        allTimeData = [allTimeData; timeData];
                        allValueData = [allValueData; scaledData];
                        
                        % Use custom color and line width if set
                        color = [];
                        width = 2;
                        if isprop(obj.App, 'SignalStyles') && ~isempty(obj.App.SignalStyles) && isfield(obj.App.SignalStyles, sigName)
                            style = obj.App.SignalStyles.(sigName);
                            if isfield(style, 'Color') && ~isempty(style.Color)
                                color = style.Color;
                                if ischar(color) || isstring(color)
                                    color = str2num(color); %#ok<ST2NM>
                                end
                            end
                            if isfield(style, 'LineWidth')
                                width = style.LineWidth;
                            end
                        end
                        if isempty(color)
                            color = colorOrder(mod(colorIdx-1, nColors)+1, :);
                            colorIdx = colorIdx + 1;
                        end
                        
                        % Check if it's a state signal
                        isStateSignal = false;
                        if obj.App.DataManager.StateSignals.isKey(sigName)
                            isStateSignal = obj.App.DataManager.StateSignals(sigName);
                        end
                        
                        if isStateSignal
                            % State signals: always recreate (vertical lines are simple)
                            obj.removeSignalPlot(ax, sigName);
                            obj.plotStateSignalStable(ax, timeData, scaledData, color, sigName, currentYLim);
                        else
                            % Regular signals: update existing or create new
                            if shouldClearAndRecreate
                                % Create new plot
                                h = plot(ax, timeData, scaledData, 'LineWidth', width, 'Color', color, 'DisplayName', sigName);
                                plotHandles(end+1) = h;
                                plotLabels{end+1} = sigName;
                            else
                                % Update existing plot or create if not found
                                h = obj.updateOrCreateSignalPlot(ax, sigName, timeData, scaledData, color, width);
                                if ~isempty(h)
                                    plotHandles(end+1) = h;
                                    plotLabels{end+1} = sigName;
                                end
                            end
                        end
                    end
                    
                    % Remove plots for signals no longer assigned (only during streaming)
                    if ~shouldClearAndRecreate
                        obj.removeUnassignedSignalPlots(ax, assignedSignalNames);
                    end
                    
                    % Show legend for regular signals
                    if ~isempty(plotHandles)
                        legend(ax, plotHandles, plotLabels, 'Location', 'best');
                    else
                        legend(ax, 'off');
                    end
                    
                    % **Smart limit management - FORCE AUTO-SCALING FOR NON-STREAMING**
                    if ~isempty(allTimeData) && ~isempty(allValueData)
                        if isStreaming
                            % Streaming mode: manually expand limits based on data
                            obj.updateLimitsForStreaming(ax, allTimeData, allValueData, currentXLim, currentYLim, hasExistingData);
                        else
                            % Not streaming: FORCE auto-scaling immediately
                            ax.XLimMode = 'auto';
                            ax.YLimMode = 'auto';
                            axis(ax, 'auto');
                            % Switch back to manual to prevent future changes
                            ax.XLimMode = 'manual';
                            ax.YLimMode = 'manual';
                        end
                    else
                        % No data case
                        if hasExistingData && ~shouldClearAndRecreate
                            ax.XLim = currentXLim;
                            ax.YLim = currentYLim;
                            ax.XLimMode = 'manual';
                            ax.YLimMode = 'manual';
                        else
                            % Empty plot - let auto-scaling work
                            if ~isStreaming
                                ax.XLimMode = 'auto';
                                ax.YLimMode = 'auto';
                            else
                                ax.XLim = [0 10];
                                ax.YLim = [-1 1];
                                ax.XLimMode = 'manual';
                                ax.YLimMode = 'manual';
                            end
                        end
                    end
                    
                    hold(ax, 'off');
                end
            end
            
            % **SIMPLIFIED: Auto-scale at the end only if needed**
            if ~isempty(axesToAutoScale)
                for ax = axesToAutoScale
                    if isvalid(ax) && isgraphics(ax)
                        ax.XLimMode = 'auto';
                        ax.YLimMode = 'auto';
                        axis(ax, 'auto');
                        ax.XLimMode = 'manual';
                        ax.YLimMode = 'manual';
                    end
                end
                % Single drawnow at the very end
                drawnow;
            end
            
            % Link all axes in all tabs on the x-axis
            obj.linkAllAxes();
            
            % Restore highlight after refresh
            obj.App.highlightSelectedSubplot(obj.CurrentTabIdx, obj.SelectedSubplotIdx);
        end

        % **NEW METHOD: Update existing signal plot or create new one**
        function h = updateOrCreateSignalPlot(obj, ax, sigName, timeData, scaledData, color, width)
            % Find existing line for this signal
            existingLine = obj.findSignalPlot(ax, sigName);
            
            if ~isempty(existingLine)
                % Update existing line data
                existingLine.XData = timeData;
                existingLine.YData = scaledData;
                existingLine.Color = color;
                existingLine.LineWidth = width;
                h = existingLine;
            else
                % Create new line
                h = plot(ax, timeData, scaledData, 'LineWidth', width, 'Color', color, 'DisplayName', sigName);
            end
        end

        % **NEW METHOD: Find existing signal plot by name**
        function line = findSignalPlot(obj, ax, sigName)
            line = [];
            if isempty(ax.Children)
                return;
            end
            
            % Look for line with matching DisplayName
            for i = 1:numel(ax.Children)
                child = ax.Children(i);
                if isa(child, 'matlab.graphics.chart.primitive.Line') && ...
                   isprop(child, 'DisplayName') && ...
                   strcmp(child.DisplayName, sigName)
                    line = child;
                    return;
                end
            end
        end

        % **NEW METHOD: Remove specific signal plot**
        function removeSignalPlot(obj, ax, sigName)
            line = obj.findSignalPlot(ax, sigName);
            if ~isempty(line) && isvalid(line)
                delete(line);
            end
        end

        % **NEW METHOD: Remove all signal plots**
        function removeAllSignalPlots(obj, ax)
            if isempty(ax.Children)
                return;
            end
            
            % Delete all line objects
            linesToDelete = [];
            for i = 1:numel(ax.Children)
                child = ax.Children(i);
                if isa(child, 'matlab.graphics.chart.primitive.Line')
                    linesToDelete = [linesToDelete, child];
                end
            end
            
            for line = linesToDelete
                if isvalid(line)
                    delete(line);
                end
            end
        end

        % **NEW METHOD: Remove plots for unassigned signals**
        function removeUnassignedSignalPlots(obj, ax, assignedSignalNames)
            if isempty(ax.Children)
                return;
            end
            
            % Find lines that are not in the assigned list
            linesToDelete = [];
            for i = 1:numel(ax.Children)
                child = ax.Children(i);
                if isa(child, 'matlab.graphics.chart.primitive.Line') && ...
                   isprop(child, 'DisplayName') && ...
                   ~isempty(child.DisplayName) && ...
                   ~ismember(child.DisplayName, assignedSignalNames)
                    linesToDelete = [linesToDelete, child];
                end
            end
            
            % Delete unassigned lines
            for line = linesToDelete
                if isvalid(line)
                    delete(line);
                end
            end
        end

        % **NEW METHOD: Update limits during streaming**
        function updateLimitsForStreaming(obj, ax, allTimeData, allValueData, currentXLim, currentYLim, hasExistingData)
            % Calculate new limits based on data
            dataXMin = min(allTimeData);
            dataXMax = max(allTimeData);
            dataYMin = min(allValueData);
            dataYMax = max(allValueData);
            
            % Calculate ranges and padding
            xRange = dataXMax - dataXMin;
            yRange = dataYMax - dataYMin;
            
            if xRange > 0
                xPadding = 0.05 * xRange;
                newXLim = [dataXMin - xPadding, dataXMax + xPadding];
            else
                newXLim = [dataXMin - 1, dataXMax + 1];
            end
            
            if yRange > 0
                yPadding = 0.1 * yRange;
                newYLim = [dataYMin - yPadding, dataYMax + yPadding];
            else
                newYLim = [dataYMin - 0.1, dataYMax + 0.1];
            end
            
            % During streaming: expand limits if needed, don't shrink
            if hasExistingData
                finalXLim = [min(currentXLim(1), newXLim(1)), max(currentXLim(2), newXLim(2))];
                finalYLim = [min(currentYLim(1), newYLim(1)), max(currentYLim(2), newYLim(2))];
            else
                finalXLim = newXLim;
                finalYLim = newYLim;
            end
            
            % Set limits
            ax.XLim = finalXLim;
            ax.YLim = finalYLim;
            ax.XLimMode = 'manual';
            ax.YLimMode = 'manual';
        end

        % **NEW METHOD: Link all axes**
        function linkAllAxes(obj)
            allAxes = [];
            for i = 1:numel(obj.AxesArrays)
                if ~isempty(obj.AxesArrays{i})
                    for j = 1:numel(obj.AxesArrays{i})
                        ax = obj.AxesArrays{i}(j);
                        if isvalid(ax) && isgraphics(ax)
                            allAxes = [allAxes, ax];
                        end
                    end
                end
            end
            if ~isempty(allAxes)
                linkaxes(allAxes, 'x');
            end
        end

        % **UPDATED METHOD: Improved state signal plotting**
        function plotStateSignalStable(obj, ax, timeData, valueData, color, label, currentYLim)
            if length(timeData) < 2
                plot(ax, timeData, valueData, 'Color', color, 'LineWidth', 2, 'DisplayName', label);
                return;
            end
            
            % Use a tolerance for floating-point changes
            changeIdx = find([true; abs(diff(valueData)) > 1e-8]);
            
            % Use current Y limits if they exist and are reasonable
            if length(currentYLim) == 2 && currentYLim(2) > currentYLim(1) && ~isequal(currentYLim, [0 1])
                yLimits = currentYLim;
            else
                if min(valueData) ~= max(valueData)
                    yRange = max(valueData) - min(valueData);
                    yPadding = 0.1 * yRange;
                    yLimits = [min(valueData) - yPadding, max(valueData) + yPadding];
                else
                    yLimits = [min(valueData) - 0.5, max(valueData) + 0.5];
                end
            end
            
            if isempty(changeIdx)
                t = timeData(1);
                plot(ax, [t t], yLimits, 'Color', color, 'LineWidth', 2, 'DisplayName', label);
            else
                for k = 1:numel(changeIdx)
                    t = timeData(changeIdx(k));
                    if k == 1
                        plot(ax, [t t], yLimits, 'Color', color, 'LineWidth', 2, 'DisplayName', label);
                    else
                        plot(ax, [t t], yLimits, 'Color', color, 'LineWidth', 2);
                    end
                end
            end
        end

        function updateAllPlotsForStreaming(obj)
            % Optimized streaming updates - uses existing line update mechanism
            obj.refreshPlots();
        end

        function selectSubplot(obj, tabIdx, subplotIdx)
            obj.SelectedSubplotIdx = subplotIdx;
            obj.App.highlightSelectedSubplot(tabIdx, subplotIdx);
            
            val = sprintf('Plot %d', subplotIdx);
            if any(strcmp(val, obj.App.SubplotDropdown.Items))
                obj.App.SubplotDropdown.Value = val;
            end
        end

        function addNewTab(obj, ~, ~)
            rows = 2; cols = 1;
            tabNum = numel(obj.PlotTabs) + 1;
            plusTabIdx = find(cellfun(@(t) strcmp(t.Title, '+'), obj.PlotTabs));
            if ~isempty(plusTabIdx)
                tab = uitab(obj.App.MainTabGroup, 'Title', sprintf('Tab %d ❌', plusTabIdx), ...
                    'BackgroundColor', [0.98 0.98 0.98]);
                cm = uicontextmenu(obj.App.UIFigure);
                uimenu(cm, 'Text', 'Close Tab', 'MenuSelectedFcn', @(src, event) obj.deleteTabByHandle(tab));
                tab.ContextMenu = cm;
                obj.PlotTabs = [obj.PlotTabs(1:plusTabIdx-1), {tab}, obj.PlotTabs(plusTabIdx:end)];
                obj.GridLayouts = [obj.GridLayouts(1:plusTabIdx-1), {uigridlayout(tab, [rows, cols], 'BackgroundColor', [0.98 0.98 0.98])}, obj.GridLayouts(plusTabIdx:end)];
                obj.AxesArrays = [obj.AxesArrays(1:plusTabIdx-1), {matlab.ui.control.UIAxes.empty}, obj.AxesArrays(plusTabIdx:end)];
                obj.AssignedSignals = [obj.AssignedSignals(1:plusTabIdx-1), {{}}, obj.AssignedSignals(plusTabIdx:end)];
                obj.TabLayouts = [obj.TabLayouts(1:plusTabIdx-1), {[rows, cols]}, obj.TabLayouts(plusTabIdx:end)];
                obj.AxesLimits = [obj.AxesLimits(1:plusTabIdx-1), {{}}, obj.AxesLimits(plusTabIdx:end)];
                obj.LastDataTime = [obj.LastDataTime(1:plusTabIdx-1), {{}}, obj.LastDataTime(plusTabIdx:end)];
                tabNum = plusTabIdx;
            else
                tab = uitab(obj.App.MainTabGroup, 'Title', sprintf('Tab %d ❌', tabNum), ...
                    'BackgroundColor', [0.98 0.98 0.98]);
                cm = uicontextmenu(obj.App.UIFigure);
                uimenu(cm, 'Text', 'Close Tab', 'MenuSelectedFcn', @(src, event) obj.deleteTabByHandle(tab));
                tab.ContextMenu = cm;
                obj.PlotTabs{end+1} = tab;
                obj.GridLayouts{end+1} = uigridlayout(tab, [rows, cols], 'BackgroundColor', [0.98 0.98 0.98]);
                obj.AxesArrays{end+1} = matlab.ui.control.UIAxes.empty;
                obj.AssignedSignals{end+1} = {};
                obj.TabLayouts{end+1} = [rows, cols];
                obj.AxesLimits{end+1} = {};
                obj.LastDataTime{end+1} = {};
            end
            obj.createSubplotsForTab(tabNum, rows, cols);
            obj.CurrentTabIdx = tabNum;
            obj.App.MainTabGroup.SelectedTab = tab;
            obj.ensurePlusTab();
        end
        
        function deleteCurrentTab(obj)
            if numel(obj.PlotTabs) <= 2
                return;
            end
            
            currentIdx = obj.CurrentTabIdx;
            if strcmp(obj.PlotTabs{currentIdx}.Title, '+')
                return;
            end
            
            delete(obj.PlotTabs{currentIdx});
            obj.PlotTabs(currentIdx) = [];
            obj.GridLayouts(currentIdx) = [];
            obj.AxesArrays(currentIdx) = [];
            obj.AssignedSignals(currentIdx) = [];
            obj.TabLayouts(currentIdx) = [];
            obj.AxesLimits(currentIdx) = [];
            obj.LastDataTime(currentIdx) = [];
            
            if currentIdx > numel(obj.PlotTabs)-1
                obj.CurrentTabIdx = numel(obj.PlotTabs)-1;
            end
            
            obj.App.MainTabGroup.SelectedTab = obj.PlotTabs{obj.CurrentTabIdx};
            obj.ensurePlusTab();
        end
        
        function deleteTabByHandle(obj, tab)
            idx = find(cellfun(@(t) t == tab, obj.PlotTabs));
            if ~isempty(idx)
                obj.CurrentTabIdx = idx;
                obj.deleteCurrentTab();
            end
        end

        function changeTabLayout(obj, tabIdx, rows, cols)
            if tabIdx <= numel(obj.PlotTabs)
                obj.createSubplotsForTab(tabIdx, rows, cols);
            end
        end

        function exportToPDF(obj)
            if obj.CurrentTabIdx > numel(obj.AxesArrays) || isempty(obj.AxesArrays{obj.CurrentTabIdx})
                uialert(obj.App.UIFigure, 'No plots to export.', 'Info');
                return;
            end

            [file, path] = uiputfile('*.pdf', 'Export Plots to PDF');
            if isequal(file, 0), return; end

            try
                exportFig = figure('Visible', 'off', 'Position', [100 100 800 600], 'Color', [1 1 1]);
                axes_array = obj.AxesArrays{obj.CurrentTabIdx};
                [rows, cols] = size(reshape(1:numel(axes_array), obj.TabLayouts{obj.CurrentTabIdx}));

                for i = 1:numel(axes_array)
                    subplot(rows, cols, i);
                    copyobj(allchild(axes_array(i)), gca);
                    title(axes_array(i).Title.String, 'Color', 'black');
                    xlabel(axes_array(i).XLabel.String, 'Color', 'black');
                    ylabel(axes_array(i).YLabel.String, 'Color', 'black');
                    set(gca, 'Color', [1 1 1], 'XColor', [0.15 0.15 0.15], 'YColor', [0.15 0.15 0.15]);
                    grid on;
                end

                print(exportFig, fullfile(path, file), '-dpdf', '-fillpage');
                close(exportFig);
                uialert(obj.App.UIFigure, '✅ PDF exported successfully!', 'Success');
            catch ME
                uialert(obj.App.UIFigure, ['❌ Export failed: ' ME.message], 'Error');
            end
        end

        function resetZoom(obj)
            if obj.CurrentTabIdx <= numel(obj.AxesArrays)
                for ax = obj.AxesArrays{obj.CurrentTabIdx}
                    if ~isvalid(ax) || ~isgraphics(ax)
                        continue;
                    end
                    
                    % Clear stored limits 
                    if obj.CurrentTabIdx <= numel(obj.AxesLimits)
                        for k = 1:numel(obj.AxesLimits{obj.CurrentTabIdx})
                            if ~isempty(obj.AxesLimits{obj.CurrentTabIdx}{k})
                                obj.AxesLimits{obj.CurrentTabIdx}{k}.HasData = false;
                            end
                        end
                    end
                    
                    % Manually calculate limits from existing plot data instead of using auto
                    if ~isempty(ax.Children)
                        allXData = [];
                        allYData = [];
                        
                        % Extract data from all line objects
                        for child = ax.Children'
                            if isa(child, 'matlab.graphics.chart.primitive.Line')
                                xData = child.XData;
                                yData = child.YData;
                                if ~isempty(xData) && ~isempty(yData)
                                    allXData = [allXData, xData];
                                    allYData = [allYData, yData];
                                end
                            end
                        end
                        
                        % Calculate proper limits from data
                        if ~isempty(allXData) && ~isempty(allYData)
                            xMin = min(allXData);
                            xMax = max(allXData);
                            yMin = min(allYData);
                            yMax = max(allYData);
                            
                            % Add padding
                            xRange = xMax - xMin;
                            yRange = yMax - yMin;
                            
                            if xRange > 0
                                xPadding = 0.05 * xRange;
                                ax.XLim = [xMin - xPadding, xMax + xPadding];
                            else
                                ax.XLim = [xMin - 1, xMax + 1];
                            end
                            
                            if yRange > 0
                                yPadding = 0.1 * yRange;
                                ax.YLim = [yMin - yPadding, yMax + yPadding];
                            else
                                ax.YLim = [yMin - 0.1, yMax + 0.1];
                            end
                        else
                            % No data, use default
                            ax.XLim = [0 10];
                            ax.YLim = [-1 1];
                        end
                    else
                        % No children, use default
                        ax.XLim = [0 10];
                        ax.YLim = [-1 1];
                    end
                    
                    % Always stay in manual mode - NO AUTO MODE
                    ax.XLimMode = 'manual';
                    ax.YLimMode = 'manual';
                end
            end
        end

        % Enable synchronized zoom/pan (link x-limits of all axes)
        function enableSyncZoom(obj)
            allAxes = [];
            for i = 1:numel(obj.AxesArrays)
                if ~isempty(obj.AxesArrays{i})
                    allAxes = [allAxes, obj.AxesArrays{i}(:)'];
                end
            end
            if ~isempty(allAxes)
                linkaxes(allAxes, 'x');
            end
        end

        % Disable synchronized zoom/pan (unlink x-limits of all axes)
        function disableSyncZoom(obj)
            allAxes = [];
            for i = 1:numel(obj.AxesArrays)
                if ~isempty(obj.AxesArrays{i})
                    allAxes = [allAxes, obj.AxesArrays{i}(:)'];
                end
            end
            if ~isempty(allAxes)
                linkaxes(allAxes, 'off');
            end
        end

        % Enable data cursor mode (data tips) for all axes
        function enableCursorMode(obj)
            for i = 1:numel(obj.AxesArrays)
                if ~isempty(obj.AxesArrays{i})
                    for ax = obj.AxesArrays{i}
                        if isvalid(ax) && isgraphics(ax)
                            try
                                ax.Interactions = [dataTipInteraction];
                            end
                        end
                    end
                end
            end
        end

        % Disable data cursor mode, restore default pan/zoom for all axes
        function disableCursorMode(obj)
            for i = 1:numel(obj.AxesArrays)
                if ~isempty(obj.AxesArrays{i})
                    for ax = obj.AxesArrays{i}
                        if isvalid(ax) && isgraphics(ax)
                            try
                                ax.Interactions = [panInteraction zoomInteraction];
                            end
                        end
                    end
                end
            end
        end
    end

    methods (Access = private)
        function ensurePlusTab(obj)
            % Remove any existing + tab
            plusTabIdx = find(cellfun(@(t) strcmp(t.Title, '+'), obj.PlotTabs));
            if ~isempty(plusTabIdx)
                delete(obj.PlotTabs{plusTabIdx});
                obj.PlotTabs(plusTabIdx) = [];
                obj.GridLayouts(plusTabIdx) = [];
                obj.AxesArrays(plusTabIdx) = [];
                obj.AssignedSignals(plusTabIdx) = [];
                obj.TabLayouts(plusTabIdx) = [];
                obj.AxesLimits(plusTabIdx) = [];
                obj.LastDataTime(plusTabIdx) = [];
            end
            % Add + tab at the end (no close icon)
            plusTab = uitab(obj.App.MainTabGroup, 'Title', '+');
            obj.PlotTabs{end+1} = plusTab;
        end
    end
end